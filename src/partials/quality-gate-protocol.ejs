## Quality Gate Protocol
<% if (typeof role !== 'undefined' && role === 'orchestrator') { -%>

### Gate Profile System

Not all work types need the same quality gates. Use the profile table below to determine which gate agents to deploy based on the work type of the changeset.

#### Gate Profile Lookup Table

| Work Type | Gate 1 (blocking) | Gate 2 (parallel) | Specialty File |
|-----------|-------------------|-------------------|----------------|
| `application_code` | reaper:test-runner | reaper:feature-developer, reaper:security-auditor | application-code.md |
| `infrastructure_config` | -- | reaper:principal-engineer, reaper:security-auditor | architecture-review.md |
| `database_migration` | -- | reaper:database-architect | database-migration.md |
| `api_specification` | -- | reaper:principal-engineer | architecture-review.md |
| `agent_prompt` | -- | reaper:ai-prompt-engineer | agent-prompt.md |
| `documentation` | -- | reaper:technical-writer | documentation.md |
| `ci_cd_pipeline` | -- | reaper:deployment-engineer, reaper:security-auditor | (none) |
| `test_code` | reaper:test-runner | reaper:feature-developer | application-code.md |
| `configuration` | -- | reaper:feature-developer, reaper:security-auditor | (none) |
| `architecture_review` | -- | reaper:principal-engineer | architecture-review.md |

For work types with no Gate 1 (`infrastructure_config`, `database_migration`, `api_specification`, `agent_prompt`, `documentation`, `ci_cd_pipeline`, `configuration`, `architecture_review`), skip directly to Gate 2.

#### Work Type Detection Patterns

Determine the work type from the files in the changeset using these patterns:

| Pattern | Work Type |
|---------|-----------|
| `src/`, `lib/`, `app/` + code extensions (.ts, .js, .py, .go, .rs, .java, .rb, .php, .cs, .kt, .swift) | `application_code` |
| `terraform/`, `k8s/`, `kubernetes/`, `docker/`, `helm/` + .tf, .yaml, .yml, Dockerfile, docker-compose.* | `infrastructure_config` |
| `migrations/`, `db/`, `schema/` + .sql, .prisma | `database_migration` |
| `openapi.`, `swagger.`, `schema.graphql`, `*.openapi.*` | `api_specification` |
| `agents/`, `prompts/`, `src/agents/`, `src/prompts/` + .md, .ejs, .txt (in prompt dirs) | `agent_prompt` |
| `docs/`, `*.md` (at root), `README*`, `CHANGELOG*` | `documentation` |
| `.github/workflows/`, `.gitlab-ci*`, `Jenkinsfile`, `.circleci/` | `ci_cd_pipeline` |
| `tests/`, `test/`, `__tests__/`, `spec/`, `*_test.*`, `*.test.*`, `*.spec.*` | `test_code` |
| `.env*`, `config/`, `*.config.*`, `*.json` (config files) | `configuration` |
| `docs/adr/`, `docs/arch/`, `design/` + .md files; files named `*.architecture.*`, `*system-design*`, `*adr-*` | `architecture_review` |

If no pattern matches, default to `application_code`.

#### Union Semantics for Mixed Changesets

When a changeset spans multiple work types, compute the union of all matching profiles:

1. Identify all work types present in the changeset using the detection patterns above
2. Collect all unique Gate 1 agents across matching profiles -- if any profile includes a Gate 1, it remains blocking
3. Collect all unique Gate 2 agents across matching profiles (deduplicated by agent name)
4. Deploy the union set through the standard gate sequence

**Example:** A changeset touching `src/auth.ts` (application_code) and `terraform/main.tf` (infrastructure_config) produces:
- Gate 1: reaper:test-runner (from application_code; infrastructure_config has no Gate 1)
- Gate 2: reaper:feature-developer (from application_code) + reaper:principal-engineer (from infrastructure_config) + reaper:security-auditor (union of both profiles; deduplicated since both include security-auditor)

#### Differential Retry Limits

Each gate agent has its own iteration limit before escalating to the user:

| Gate Agent | Max Iterations | Rationale |
|------------|---------------|-----------|
| reaper:test-runner | 3 | Most likely to need iteration (test failures, coverage gaps) |
| Gate 2 reviewer (any) | 1 | One focused pass per iteration |
| reaper:security-auditor | 1 | Security issues require careful one-pass remediation |

### Gate Sequence (never skip)

All work passes through two sequential gates before reaching the user. There are no exceptions -- even when a coding agent reports that everything is clean, run both gates.

The gate agents to deploy depend on the work type profile determined above. The `application_code` profile (the default) uses:

**Gate 1 (blocking):** Deploy reaper:test-runner. Must pass before Gate 2 proceeds.

**Gate 2 (parallel):** Deploy the Gate 2 agents from the Gate Profile Lookup Table simultaneously in a single message. All must pass.

For other profiles, substitute the appropriate agents from the Gate Profile Lookup Table. For work types with no Gate 1, proceed directly to Gate 2.

**Gate 2 dispatch:** Look up the Gate 2 column in the profile table to identify the reviewer agent and its specialty file for the detected work type, then invoke the Gate 2 reviewer as a fresh Task:

```
Task --subagent_type <gate2_reviewer_agent> --prompt "
TASK: <task_id>
WORKTREE: <worktree_path>
SCOPE: <scope_globs>
PLAN_CONTEXT: <materialized_plan_content>
SKILL_CONTENT: <contents of skills/code-review/SKILL.md>
SPECIALTY_CONTENT: <contents of skills/code-review/<specialty_file>.md, if applicable>
"
```

- `SKILL_CONTENT`: read `skills/code-review/SKILL.md` from the repo root and inject the full text
- `SPECIALTY_CONTENT`: read the matching specialty file (e.g., `skills/code-review/application-code.md`) and inject the full text; omit this field entirely if the work type has no specialty file (`(none)` in the table)
- `PLAN_CONTEXT`: the materialized plan content injected by takeoff before gate dispatch
- Always use a fresh Task invocation for the Gate 2 reviewer -- never resume from the coding agent
- **Mixed changesets**: when multiple work types are detected, deploy the Gate 2 agents listed for each detected work type in parallel

After all gates pass, present completed work to the user and seek feedback.

### JSON Validation Keys

Parse these fields from each gate agent's JSON response to determine pass/fail:

| Key | Source | Pass Condition |
|-----|--------|----------------|
| `test_exit_code` | reaper:test-runner | `=== 0` |
| `coverage_percentage` | reaper:test-runner | target 80%+ (use project threshold if configured) |
| `lint_exit_code` | reaper:test-runner | `=== 0` |
| `all_checks_passed` | all gate agents | `=== true` |
| `blocking_issues` | all gate agents | empty array |
| `pre_work_validation.validation_passed` | all agents | `=== true` |
| `files_modified` | all agents | within specified scope |

**Red flags (immediately redeploy the agent):**
- `pre_work_validation.validation_passed: false` or `exit_reason` is not null
- Logical inconsistency: `test_exit_code: 0` but `tests_failed > 0`
- Scope violation: `files_modified` lists paths outside the assigned scope or worktree
- Missing evidence: no `commands_executed` or `verification_evidence` in the response
- Extreme outlier: 100% coverage on first attempt with no prior test infrastructure

### Iteration Rules

- On any gate failure, redeploy the coding agent with `blocking_issues` from the failed gate
- After the coding agent addresses issues, re-run the failed gate (not all gates)
- Apply differential retry limits per agent (see table above) before escalating to the user
- Work autonomously through iterations without asking the user for guidance

#### Resume-Based Retry

Capture the `agent_id` from every Task tool response. When a gate fails and the coding agent must address issues, prefer `Task --resume` over a full redeployment. This reduces retry cost from ~3,000 tokens to 50-100 tokens.

**Resume prompt template:**
```
Task --resume $AGENT_ID --prompt "Gate failed. Fix these blocking_issues: [paste blocking_issues array from gate response]"
```

**Resume-vs-fresh decision table:**

| Condition | Action |
|-----------|--------|
| Same gate failed, agent_id available | Resume with blocking_issues |
| Different gate failed than last time | Resume with blocking_issues from new gate |
| Agent ID is stale (error on resume) | Fresh deployment with full context |
| Max retries exceeded | Escalate to user |

### Commit on Pass

After each gate passes, deploy reaper:branch-manager to commit the current state on the feature branch using conventional commit format:
- Tests pass: `test: all tests passing with X% coverage`
- Lint fixed: `style: fix linting errors`
- Review issues fixed: `refactor: address code review feedback`

Commits go to the feature branch only — never master, main, or develop — unless the user prescribes otherwise.

Frequent commits on feature branches create restore points and document progress.

### Parallel Deployment Pattern

After Gate 1 passes, deploy Gate 2 agents in a single message. Look up the Gate 2 column in the profile table and deploy the Gate 2 agents listed for the detected work type in parallel.

See the Gate 2 dispatch instructions above for the full prompt structure to use when invoking the Gate 2 reviewer.

If either fails, combine `blocking_issues` from both before redeploying the coding agent.

### Information Handoff

- **Coding agent to reaper:test-runner**: Pass `narrative_report.summary` for test scope context, plus TEST_COMMAND and LINT_COMMAND from project config
- **reaper:test-runner to Gate 2 reviewer**: Pass full test results JSON (test_exit_code, coverage_percentage, lint_exit_code, test_metrics) alongside SKILL_CONTENT, SPECIALTY_CONTENT, and PLAN_CONTEXT
- **reaper:test-runner to reaper:security-auditor**: Pass plan context only (security-auditor does not need test results)
<% } else { -%>

### Gate Profiles

Quality gates are work-type-aware. The orchestrator selects gate agents based on the type of work in the changeset:

| Work Type | Gate 1 (blocking) | Gate 2 (parallel) |
|-----------|-------------------|-------------------|
| `application_code` | test-runner | feature-developer, security-auditor |
| `infrastructure_config` | -- | principal-engineer, security-auditor |
| `database_migration` | -- | database-architect |
| `api_specification` | -- | principal-engineer |
| `agent_prompt` | -- | ai-prompt-engineer |
| `documentation` | -- | technical-writer |
| `ci_cd_pipeline` | -- | deployment-engineer, security-auditor |
| `test_code` | test-runner | feature-developer |
| `configuration` | -- | feature-developer, security-auditor |
| `architecture_review` | -- | principal-engineer |

**Work type detection** uses directory paths and file extensions (e.g., `src/` + `.ts` = `application_code`, `terraform/` + `.tf` = `infrastructure_config`). Mixed changesets use the union of all matching profiles.

**Default profile:** `application_code` -- reaper:test-runner (Gate 1) then reaper:feature-developer (with code-review skill) + reaper:security-auditor (Gate 2).

Auto-iteration on failure with per-agent retry limits (test-runner: 3, Gate 2 reviewers: 1). The takeoff skill owns gate execution and iteration.

Gate status rendering uses the vocabulary defined in the visual-vocabulary partial (PASS, FAIL, RUNNING, PENDING, SKIP). These are inspection verdicts for gate results, distinct from gauge states which track work unit lifecycle.
<% } -%>
