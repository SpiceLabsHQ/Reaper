## Quality Gate Protocol
<% if (typeof role !== 'undefined' && role === 'orchestrator') { -%>

### Gate Profile System

Not all work types need the same quality gates. Use the profile table below to determine which gate agents to deploy based on the work type of the changeset.

#### Gate Profile Lookup Table

| Work Type | Gate 1 (blocking) | Gate 2 (parallel) | Notes |
|-----------|-------------------|-------------------|-------|
| `application_code` | reaper:test-runner | reaper:code-reviewer, reaper:security-auditor | Default for source code -- full gate sequence |
| `infrastructure_config` | reaper:validation-runner | reaper:security-auditor | Terraform, Kubernetes, Docker, Helm |
| `database_migration` | reaper:validation-runner | reaper:code-reviewer | Schema changes, migration files |
| `api_specification` | reaper:validation-runner | reaper:code-reviewer | OpenAPI, GraphQL schema definitions |
| `agent_prompt` | -- | reaper:ai-prompt-engineer, reaper:code-reviewer | No Gate 1 -- Gate 2 runs immediately |
| `documentation` | -- | reaper:code-reviewer | No Gate 1 -- Gate 2 runs immediately |
| `ci_cd_pipeline` | reaper:validation-runner | reaper:security-auditor, reaper:deployment-engineer | CI/CD pipeline configurations |
| `test_code` | reaper:test-runner | reaper:code-reviewer | Test files themselves |
| `configuration` | reaper:validation-runner | reaper:security-auditor | Application config files |

For work types with no Gate 1 (`agent_prompt`, `documentation`), skip directly to Gate 2.

#### Work Type Detection Patterns

Determine the work type from the files in the changeset using these patterns:

| Pattern | Work Type |
|---------|-----------|
| `src/`, `lib/`, `app/` + code extensions (.ts, .js, .py, .go, .rs, .java, .rb, .php, .cs, .kt, .swift) | `application_code` |
| `terraform/`, `k8s/`, `kubernetes/`, `docker/`, `helm/` + .tf, .yaml, .yml, Dockerfile, docker-compose.* | `infrastructure_config` |
| `migrations/`, `db/`, `schema/` + .sql, .prisma | `database_migration` |
| `openapi.`, `swagger.`, `schema.graphql`, `*.openapi.*` | `api_specification` |
| `agents/`, `prompts/`, `src/agents/`, `src/prompts/` + .md, .ejs, .txt (in prompt dirs) | `agent_prompt` |
| `docs/`, `*.md` (at root), `README*`, `CHANGELOG*` | `documentation` |
| `.github/workflows/`, `.gitlab-ci*`, `Jenkinsfile`, `.circleci/` | `ci_cd_pipeline` |
| `tests/`, `test/`, `__tests__/`, `spec/`, `*_test.*`, `*.test.*`, `*.spec.*` | `test_code` |
| `.env*`, `config/`, `*.config.*`, `*.json` (config files) | `configuration` |

If no pattern matches, default to `application_code`.

#### Union Semantics for Mixed Changesets

When a changeset spans multiple work types, compute the union of all matching profiles:

1. Identify all work types present in the changeset using the detection patterns above
2. Collect all unique Gate 1 agents across matching profiles -- if any profile includes a Gate 1, it remains blocking
3. Collect all unique Gate 2 agents across matching profiles (deduplicated)
4. Deploy the union set through the standard gate sequence

**Example:** A changeset touching `src/auth.ts` (application_code) and `terraform/main.tf` (infrastructure_config) produces:
- Gate 1: reaper:test-runner + reaper:validation-runner (both blocking, run in parallel)
- Gate 2: reaper:code-reviewer + reaper:security-auditor (union of both profiles)

#### Differential Retry Limits

Each gate agent has its own iteration limit before escalating to the user:

| Gate Agent | Max Iterations | Rationale |
|------------|---------------|-----------|
| reaper:test-runner | 3 | Most likely to need iteration (test failures, coverage gaps) |
| reaper:code-reviewer | 2 | Review feedback is typically addressed in fewer cycles |
| reaper:validation-runner | 1 | Validation either passes or has fundamental issues |
| reaper:security-auditor | 1 | Security issues require careful one-pass remediation |
| reaper:ai-prompt-engineer | 1 | Prompt quality review is typically one-pass |
| reaper:deployment-engineer | 1 | Pipeline validation is typically one-pass |

### Gate Sequence (never skip)

All work passes through two sequential gates before reaching the user. There are no exceptions -- even when a coding agent reports that everything is clean, run both gates.

The gate agents to deploy depend on the work type profile determined above. The `application_code` profile (the default) uses:

**Gate 1 (blocking):** Deploy reaper:test-runner. Must pass before Gate 2 proceeds.

**Gate 2 (parallel):** Deploy reaper:code-reviewer and reaper:security-auditor simultaneously in a single message. Both must pass.

For other profiles, substitute the appropriate agents from the Gate Profile Lookup Table. For work types with no Gate 1, proceed directly to Gate 2.

After all gates pass, present completed work to the user and seek feedback.

### JSON Validation Keys

Parse these fields from each gate agent's JSON response to determine pass/fail:

| Key | Source | Pass Condition |
|-----|--------|----------------|
| `test_exit_code` | reaper:test-runner | `=== 0` |
| `coverage_percentage` | reaper:test-runner | target 80%+ (use project threshold if configured) |
| `lint_exit_code` | reaper:test-runner | `=== 0` |
| `all_checks_passed` | all gate agents | `=== true` |
| `blocking_issues` | all gate agents | empty array |
| `pre_work_validation.validation_passed` | all agents | `=== true` |
| `files_modified` | all agents | within specified scope |

**Red flags (immediately redeploy the agent):**
- `pre_work_validation.validation_passed: false` or `exit_reason` is not null
- Logical inconsistency: `test_exit_code: 0` but `tests_failed > 0`
- Scope violation: `files_modified` lists paths outside the assigned scope or worktree
- Missing evidence: no `commands_executed` or `verification_evidence` in the response
- Extreme outlier: 100% coverage on first attempt with no prior test infrastructure

### Iteration Rules

- On any gate failure, redeploy the coding agent with `blocking_issues` from the failed gate
- After the coding agent addresses issues, re-run the failed gate (not all gates)
- Apply differential retry limits per agent (see table above) before escalating to the user
- Work autonomously through iterations without asking the user for guidance

### Commit on Pass

After each gate passes, deploy reaper:branch-manager to commit the current state on the feature branch using conventional commit format:
- Tests pass: `test: all tests passing with X% coverage`
- Lint fixed: `style: fix linting errors`
- Review issues fixed: `refactor: address code review feedback`

Frequent commits on feature branches create restore points and document progress.

### Parallel Deployment Pattern

After Gate 1 passes, deploy Gate 2 agents in a single message with two Task calls:
```
Task --subagent_type reaper:code-reviewer --prompt "..."
Task --subagent_type reaper:security-auditor --prompt "..."
```

If either fails, combine `blocking_issues` from both before redeploying the coding agent.

### Information Handoff

- **Coding agent to reaper:test-runner**: Pass `narrative_report.summary` for test scope context, plus TEST_COMMAND and LINT_COMMAND from project config
- **reaper:test-runner to reaper:code-reviewer**: Pass full test results JSON (test_exit_code, coverage_percentage, lint_exit_code, test_metrics)
- **reaper:test-runner to reaper:security-auditor**: Pass plan context only (security-auditor does not need test results)
<% } else { -%>

### Gate Profiles

Quality gates are work-type-aware. The orchestrator selects gate agents based on the type of work in the changeset:

| Work Type | Gate 1 (blocking) | Gate 2 (parallel) |
|-----------|-------------------|-------------------|
| `application_code` | test-runner | code-reviewer, security-auditor |
| `infrastructure_config` | validation-runner | security-auditor |
| `database_migration` | validation-runner | code-reviewer |
| `api_specification` | validation-runner | code-reviewer |
| `agent_prompt` | -- | ai-prompt-engineer, code-reviewer |
| `documentation` | -- | code-reviewer |
| `ci_cd_pipeline` | validation-runner | security-auditor, deployment-engineer |
| `test_code` | test-runner | code-reviewer |
| `configuration` | validation-runner | security-auditor |

**Work type detection** uses directory paths and file extensions (e.g., `src/` + `.ts` = `application_code`, `terraform/` + `.tf` = `infrastructure_config`). Mixed changesets use the union of all matching profiles.

**Default profile:** `application_code` -- reaper:test-runner (Gate 1) then reaper:code-reviewer + reaper:security-auditor (Gate 2).

Auto-iteration on failure with per-agent retry limits (test-runner: 3, code-reviewer: 2, all others: 1). The takeoff skill owns gate execution and iteration.

Gate status rendering uses the vocabulary defined in the visual-vocabulary partial (PASS, FAIL, RUNNING, PENDING, SKIP). These are inspection verdicts for gate results, distinct from gauge states which track work unit lifecycle.
<% } -%>
