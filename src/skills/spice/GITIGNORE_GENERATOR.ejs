---
name: gitignore-generator
description: Generates .gitignore files from templates based on detected tech stack. Activates for new projects, when .gitignore is missing, or when updating ignore patterns. Combines multiple templates and adds SPICE-specific patterns.
allowed-tools: [Bash, Read]
---

# SPICE GitIgnore Generator Skill

Generates comprehensive .gitignore files from templates based on detected technology stack, combining multiple sources and adding SPICE-specific patterns.

## Activation Triggers

This skill automatically activates when:
- Initializing new projects without .gitignore
- .gitignore is missing or incomplete
- Adding new technologies to existing projects
- User requests gitignore generation or updates

## Tech Stack Auto-Detection

```bash
detect_tech_stack() {
    local worktree_path="$1"

    echo "=== Detecting Technology Stack ==="

    TECH_STACK=""

    # Node.js
    if [ -f "$worktree_path/package.json" ]; then
        TECH_STACK="$TECH_STACK,Node"
        echo "✓ Node.js detected"
    fi

    # Python
    if [ -f "$worktree_path/requirements.txt" ] || [ -f "$worktree_path/pyproject.toml" ]; then
        TECH_STACK="$TECH_STACK,Python"
        echo "✓ Python detected"
    fi

    # Ruby
    if [ -f "$worktree_path/Gemfile" ]; then
        TECH_STACK="$TECH_STACK,Ruby"
        echo "✓ Ruby detected"
    fi

    # PHP
    if [ -f "$worktree_path/composer.json" ]; then
        TECH_STACK="$TECH_STACK,PHP"
        echo "✓ PHP detected"
    fi

    # Go
    if [ -f "$worktree_path/go.mod" ]; then
        TECH_STACK="$TECH_STACK,Go"
        echo "✓ Go detected"
    fi

    # Rust
    if [ -f "$worktree_path/Cargo.toml" ]; then
        TECH_STACK="$TECH_STACK,Rust"
        echo "✓ Rust detected"
    fi

    # Always add OS-specific
    if [ "$(uname)" = "Darwin" ]; then
        TECH_STACK="$TECH_STACK,macOS"
    elif [ "$(uname)" = "Linux" ]; then
        TECH_STACK="$TECH_STACK,Linux"
    fi

    # Always add common editors
    TECH_STACK="$TECH_STACK,VisualStudioCode,JetBrains"

    # Remove leading comma
    TECH_STACK="${TECH_STACK#,}"

    echo ""
    echo "Detected stack: $TECH_STACK"
    export TECH_STACK
}
```

## Fetch Templates from gitignore.io

```bash
fetch_gitignore_template() {
    local tech_stack="$1"
    local output_file="$2"

    echo "=== Fetching Templates from gitignore.io ==="

    # Use gitignore.io API
    GITIGNORE_URL="https://www.toptal.com/developers/gitignore/api/$tech_stack"

    echo "Fetching: $GITIGNORE_URL"
    curl -sL "$GITIGNORE_URL" -o "$output_file" || {
        echo "ERROR: Failed to fetch templates"
        return 1
    }

    echo "✅ Templates fetched successfully"
    return 0
}
```

## Add SPICE-Specific Patterns

```bash
add_spice_patterns() {
    local gitignore_file="$1"

    echo "=== Adding SPICE-Specific Patterns ==="

    cat >> "$gitignore_file" <<'EOF'

# ========================================
# SPICE Development Patterns
# ========================================

# Worktree directories
trees/

# Environment variables
.env
.env.local
.env.*.local

# SPICE tracking files
PARALLEL_WORK.md

# Dependency update artifacts
outdated.json
audit.json
DEPENDENCY_UPDATE_SUMMARY.md

# Documentation build artifacts
ENV_VARIABLES.md

EOF

    echo "✅ SPICE patterns added"
}
```

## Merge with Existing .gitignore

```bash
merge_with_existing() {
    local worktree_path="$1"
    local new_gitignore="$2"

    if [ -f "$worktree_path/.gitignore" ]; then
        echo "=== Merging with Existing .gitignore ==="

        # Backup existing
        cp "$worktree_path/.gitignore" "$worktree_path/.gitignore.backup"
        echo "✅ Backed up existing .gitignore"

        # Extract custom entries (not in template)
        CUSTOM_ENTRIES=$(grep -v '^#' "$worktree_path/.gitignore" | grep -v '^$' | sort -u)

        # Append custom entries to new template
        if [ -n "$CUSTOM_ENTRIES" ]; then
            echo "" >> "$new_gitignore"
            echo "# ========================================" >> "$new_gitignore"
            echo "# Custom Project Patterns" >> "$new_gitignore"
            echo "# ========================================" >> "$new_gitignore"
            echo "" >> "$new_gitignore"
            echo "$CUSTOM_ENTRIES" >> "$new_gitignore"
        fi

        echo "✅ Merged custom patterns"
    fi
}
```

## Sort and Deduplicate

```bash
sort_and_deduplicate() {
    local gitignore_file="$1"

    echo "=== Sorting and Deduplicating ==="

    # Extract sections
    COMMENTS=$(grep '^#' "$gitignore_file")
    PATTERNS=$(grep -v '^#' "$gitignore_file" | grep -v '^$' | sort -u)

    # Rebuild file with sections
    cat > "$gitignore_file" <<EOF
# Generated by SPICE GitIgnore Generator
# Date: $(date +%Y-%m-%d)

$COMMENTS

$PATTERNS
EOF

    echo "✅ File organized"
}
```

## Add Section Comments

```bash
organize_with_sections() {
    local gitignore_file="$1"

    echo "=== Organizing into Sections ==="

    # This is handled by gitignore.io templates
    # Just ensure SPICE section is clearly marked

    if ! grep -q "SPICE Development Patterns" "$gitignore_file"; then
        add_spice_patterns "$gitignore_file"
    fi

    echo "✅ Sections organized"
}
```

## Complete Generation Workflow

```bash
#!/bin/bash
# Complete .gitignore generation workflow

WORKTREE_PATH="$1"

if [ -z "$WORKTREE_PATH" ]; then
    WORKTREE_PATH="."
fi

if [ ! -d "$WORKTREE_PATH" ]; then
    echo "ERROR: Directory not found at $WORKTREE_PATH"
    exit 1
fi

echo "╔════════════════════════════════════════╗"
echo "║  SPICE GitIgnore Generator             ║"
echo "╚════════════════════════════════════════╝"
echo ""

# Step 1: Detect tech stack
detect_tech_stack "$WORKTREE_PATH"

if [ -z "$TECH_STACK" ]; then
    echo "ERROR: No technologies detected"
    echo "Specify manually: TECH_STACK=\"Node,Python,macOS,VisualStudioCode\""
    exit 1
fi

# Step 2: Fetch templates
TEMP_FILE="/tmp/gitignore-$$.tmp"
fetch_gitignore_template "$TECH_STACK" "$TEMP_FILE" || exit 1

# Step 3: Add SPICE patterns
add_spice_patterns "$TEMP_FILE"

# Step 4: Merge with existing (if present)
merge_with_existing "$WORKTREE_PATH" "$TEMP_FILE"

# Step 5: Sort and deduplicate
sort_and_deduplicate "$TEMP_FILE"

# Step 6: Move to final location
mv "$TEMP_FILE" "$WORKTREE_PATH/.gitignore"

echo ""
echo "=== Summary ==="
echo "✅ .gitignore generated successfully"
echo "✅ Location: $WORKTREE_PATH/.gitignore"
echo "✅ Tech stack: $TECH_STACK"
echo ""
echo "Review the file and commit:"
echo "  git add .gitignore"
echo "  git commit -m \"chore: add comprehensive .gitignore\""
echo ""
```

## Common Issues and Solutions

### Issue: Template fetch fails due to network

**Cause:** No internet or gitignore.io unavailable

**Solution:**
```bash
# Use GitHub's gitignore templates instead
git clone https://github.com/github/gitignore.git /tmp/gitignore-templates

# Combine relevant templates
cat /tmp/gitignore-templates/Node.gitignore \
    /tmp/gitignore-templates/Python.gitignore \
    > .gitignore

# Add SPICE patterns manually
cat >> .gitignore <<EOF
trees/
.env
PARALLEL_WORK.md
EOF
```

### Issue: Too many patterns slow down git operations

**Cause:** Overly broad patterns

**Solution:**
```bash
# Use specific patterns instead of wildcards
# ❌ BAD: *
# ✅ GOOD: *.log

# Review and remove unused patterns
# Check what's actually ignored:
git status --ignored
```

### Issue: Files already committed are not ignored

**Cause:** .gitignore only affects untracked files

**Solution:**
```bash
# Remove from git but keep local file
git rm --cached <file>
git commit -m "chore: remove accidentally committed file"

# Add to .gitignore
echo "<file>" >> .gitignore
git add .gitignore
git commit -m "chore: update .gitignore"
```

## Validation Checklist

Before considering .gitignore complete, verify:

- [ ] All detected technologies have patterns
- [ ] SPICE-specific patterns included (trees/, .env, etc.)
- [ ] Existing custom patterns preserved
- [ ] No duplicate patterns
- [ ] Sections clearly commented
- [ ] File committed to repository
- [ ] No sensitive files currently tracked

## Integration with SPICE Workflow

This skill integrates at key points:

1. **Project Initialization**: Generate .gitignore for new projects
2. **Technology Additions**: Update when adding new languages/frameworks
3. **Security Audits**: Ensure sensitive files are ignored
4. **Onboarding**: Help new developers understand ignored files

Comprehensive .gitignore files prevent accidental commits of sensitive data, build artifacts, and IDE configurations.

## References

- ENV Validator: `~/.claude/skills/spice/ENV_VALIDATOR.md`
- EditorConfig Generator: `~/.claude/skills/spice/EDITORCONFIG_GENERATOR.md`
- gitignore.io: https://www.toptal.com/developers/gitignore
- GitHub gitignore templates: https://github.com/github/gitignore
