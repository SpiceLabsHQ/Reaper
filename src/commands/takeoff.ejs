---
description: Dispatch agents through quality gates until work lands on your desk.
---

<%- include('partials/user-comms-contract') %>

# Work Supervisor Mode with Iterative Quality Loops

**Task**: [ARGUMENTS]

<%- include('partials/orchestrator-role-boundary') %>

<!-- user-comms: say "checking the task system" not "detecting TASK_SYSTEM" -->
<!-- user-comms: say "your project's task tracking setup" not "TASK_SYSTEM" -->
<%- include('partials/task-system-operations') %>

### Platform Skill Loading

<!-- user-comms: say "loading the right tools for your task tracker" not "Platform Skill Routing table" -->
After detecting TASK_SYSTEM, load the corresponding skill from the Platform Skill Routing table above. The loaded skill provides platform-specific command mappings for all abstract operations used throughout this command.

<%- include('partials/visual-vocabulary', { context: 'takeoff' }) %>

## Input Processing

### Parse User Input

Extract from [ARGUMENTS] using natural language understanding:

1. **Task identifier** -- look for task-like patterns (PROJ-123, repo-a3f, #456, sprint-5-auth). May be absent.
2. **Worktree path** -- look for an explicit `./trees/...` path. May be absent.
3. **Description** -- all remaining text after extracting the above.

### Validation Rules

<!-- user-comms: say "checking the task system" not "detecting TASK_SYSTEM" -->
The orchestrator can start with just a task ID (unlike coding agents) because it can query the task system.

<!-- user-comms: say "retrieving task details" not "FETCH_ISSUE" -->
- **Task ID provided**: Use FETCH_ISSUE to retrieve details. If the query fails and no description was provided, reject the input.
- **No task ID**: Require a detailed description (more than 10 characters). Generate a slug-based task ID from the description.
- **Both provided**: Combine fetched details with the user-provided description for richer context.

**Valid inputs:**
- "PROJ-123" (fetches details from Jira)
- "repo-a3f" (fetches details from Beads)
- "PROJ-123: Fix login bug where email validation fails for plus signs" (enriched)
- "Fix the payment timeout issue - transactions over 30s fail, need retry logic" (description-only)

**Invalid inputs (reject):**
- "fix bug" (too vague, no task ID)
- "" (empty)

### Build Context

After parsing, assemble the implementation context:
- If FETCH_ISSUE succeeded, use the fetched details (and append any user-provided description)
- If no task system query was possible, use the user description as the full context
- Set WORKTREE_PATH to the user-specified path, or generate one as `./trees/[TASK_ID]-work`

## Plan File Discovery

Search `.claude/plans/` for a matching plan file from a prior `/reaper:flight-plan` session. Match by task ID in filename first, then by task ID in file contents. When a match is found, read the file and extract sections according to the priority below.

<%- include('partials/plan-file-schema', { mode: 'reader' }) %>

Append any extracted Research and Strategy sections to the implementation context so downstream agents receive codebase insights gathered during planning.

## Pre-Planned Detection

Check whether the task already has child issues with acceptance criteria (indicating it was decomposed during flight-plan):

1. Use LIST_CHILDREN to get direct children of the task
2. If children exist and have acceptance criteria, mark the task as **pre-planned**
3. Use QUERY_DEPENDENCY_TREE to retrieve the full hierarchy from the root task

### Full Tree Scope

Takeoff always executes the **entire descendant tree** of the given task. If a parent issue is passed, every non-closed descendant at every level must be completed before the task is considered done.

### Tree Flattening

After retrieving children, determine whether any child itself has children (check via LIST_CHILDREN on each direct child, or inspect the QUERY_DEPENDENCY_TREE result):

- **Depth 1 (all children are leaf tasks)**: Use children directly as work units.
- **Depth > 1 (children have their own children)**: Flatten to leaf-level work units. Intermediate nodes (phases, stories, epics) become **grouping labels** for organizing work, not work units themselves. Only leaf-level issues -- those with no children of their own -- are executable work units.

When flattening, preserve the grouping structure for TodoWrite: use the intermediate node's title as the group label and assign its leaf descendants sequential step numbers within that group (e.g., "Phase 1: Backend" becomes the group heading for steps 1.1, 1.2, 1.3).

### Work Unit Extraction

**If pre-planned**: Extract leaf-level work units using the full scope rule:
- **Closed** leaves: skip (already completed)
- **Open, unblocked** leaves: execute immediately
- **Open, blocked** leaves: execute after their blockers complete

Dependencies determine execution ORDER, not whether a task is included. Every non-closed leaf must appear in the plan.

Select strategy based on the count of non-closed **leaf-level** work units: 1 uses very_small_direct, 2-4 uses medium_single_branch, 5+ uses large_multi_worktree.

**File-convergence exception**: If all leaf-level work units target the same 1-2 files (based on assigned_files or acceptance criteria), override to very_small_direct regardless of unit count. Parallel agents cannot claim exclusive file ownership when all units touch the same files.

**If not pre-planned**: Proceed to the Planning section below.

## Worktree Management

Use the `worktree-manager` skill for all worktree operations (creation, status checks, cleanup). Never run `git worktree remove` or `rm -rf` on worktree paths directly -- these can break the Bash tool's working directory for the rest of the session.

## Planning

When the plan file already contains Work Units and Strategy, skip the planner and use those directly.

Otherwise, deploy reaper:workflow-planner to analyze the task and produce a strategy selection with work units. Pass the full implementation context (including any plan file research) as input.

If the plan file has Research but no Work Units, deploy the planner with the research as additional context so it does not repeat codebase investigation.

## Work Package Validation

After obtaining work units (from pre-planned extraction, plan file, or workflow-planner), validate each package:

- Maximum 5 files per work unit
- Maximum 500 lines of code per work unit
- Maximum 2 hours estimated per work unit

If any package exceeds these limits, redeploy reaper:workflow-planner with instructions to split the oversized packages into smaller, context-safe units.

<%- include('partials/todowrite-plan-protocol') %>

## Preflight Announcement

After writing the plan to TodoWrite and before executing the first work unit, render a **Preflight Card** to the user. This gives the developer a clear snapshot of what is about to happen.

Use the Preflight Card template from the Visual Vocabulary above. Populate it with:
- **Task**: the resolved task ID
- **Branch**: the feature branch name (or "TBD" if not yet created)
- **Worktree**: the resolved WORKTREE_PATH
- **Units**: count of non-closed work units from the plan
- **Strategy**: the selected execution strategy (very_small_direct, medium_single_branch, or large_multi_worktree)

The card ends with the `TAXIING` gauge, indicating work has not yet started.

## Strategy Execution

Execute ALL work units from the plan. Do not present work to the user or proceed to the Completion section until every work unit in the TodoWrite plan is marked completed.

### Per-Unit Cycle -- REPEAT until all units done

For each work unit in the plan, repeat this cycle:

1. Update TodoWrite to mark the unit as in_progress. For tracked issues (Beads/Jira/GitHub, non-markdown_only platforms), also use UPDATE_ISSUE to mark the corresponding child issue as in_progress.
2. **Render TAKING OFF announcement**: Before deploying the agent, render a single-line gauge announcement to signal that execution is about to begin for this unit:
   ```
     ███░░░░░░░  TAKING OFF  Step X.Y: [unit name]
   ```
   This is distinct from the Preflight Card (which uses `TAXIING` to show work is queued). The TAKING OFF gauge fires once per work unit, immediately before the agent is deployed, giving the developer a clear signal that this specific unit is now launching.
3. Deploy the specified coding agent using the deployment template below
4. **Transition to ON APPROACH**: When the coding agent completes, the work unit enters the ON APPROACH state (coding done, quality gates not yet started). This is a transient state before gates begin.
5. Run quality gates on the completed work (see Dynamic Gate Selection and Quality Gate Protocol below)
6. **Render Gate Panel**: After all gates for the current unit resolve, render a Gate Panel (from Visual Vocabulary) showing each gate agent with its gate status -- `PASS` for passed, `FAIL` for failed. Include key metrics inline (e.g., test count, coverage percentage, issue count).
<%- include('partials/work-unit-cleanup') %>
7. Update TodoWrite to mark the unit as completed
<!-- user-comms: say "marking the task complete" not "CLOSE_ISSUE" -->
8. For any tracked issue (pre-planned or not) on non-markdown_only platforms, use CLOSE_ISSUE to close the corresponding child issue after gates pass.
9. **large_multi_worktree strategy only**: After closing the issue, check that no other work units still reference this worktree, then invoke the worktree-manager skill to remove the per-unit worktree. Always go through the worktree-manager skill -- never run `git worktree remove` directly.
10. **Announce progress and loop back**: "Completed [X] of [N] work units. Next: [unit name]." -- then return to step 1 for the next unit

This cycle repeats for every work unit. The Completion section is only reachable after the final unit passes its gates.

### Continuation Rule

After completing a work unit and its gates:

1. Use **TaskList** to read all TodoWrite entries (do not rely on memory -- re-read the actual state)
2. Count entries with status "pending" or "in_progress", excluding "User review", "Merge", "Close", and "Clean up" entries
3. If count > 0, announce "N work units remain" and proceed to the next pending entry
4. Only move to Completion and User Feedback when count === 0

When multiple work units share a group number and have no mutual dependencies, deploy their agents in parallel (multiple Task calls in a single message).

**Update TodoWrite immediately after each state change** -- never batch updates. If the session disconnects, the TodoWrite plan is the recovery mechanism.

### Strategy Notes

- **very_small_direct**: Create a feature branch and shared worktree (e.g., `./trees/TASK-ID-work`), then deploy a single coding agent. Quality gates still apply. Use reaper:branch-manager or the worktree-manager skill to set up the worktree.
- **medium_single_branch**: Create a single shared worktree (e.g., `./trees/TASK-ID-work`) on a feature branch. Agents work within that worktree sequentially or in parallel. File assignments must not overlap for parallel work. Worktree cleanup happens at Completion after all units pass gates.
- **large_multi_worktree**: Each agent gets its own worktree. Use the worktree-manager skill to create isolated worktrees. Deploy reaper:branch-manager to merge completed worktrees. Remove each per-unit worktree immediately after gates pass (via worktree-manager).

### Context Hygiene for Long Sessions

Sessions with 6 or more work units accumulate context that degrades orchestrator decision quality. Apply these practices:

1. **Rely on worktree isolation** -- The `large_multi_worktree` strategy keeps each agent's context fresh by design. Do not carry agent implementation details forward between units.
2. **Summarize, do not accumulate** -- After each unit's gates pass, retain only the one-line summary (task name, pass/fail, files touched). Discard full agent output and gate JSON.
3. **TodoWrite is the source of truth** -- If progress state is uncertain after many iterations, re-read TodoWrite rather than reconstructing state from memory. The plan persists; your recall of early units does not.
4. **Front-load complex units** -- When ordering permits, schedule the hardest work units first while orchestrator context is cleanest.

## Dynamic Gate Selection

After a coding agent completes work, determine the appropriate quality gates:

### Step 1: Classify Files
From the coding agent's `files_modified` list, classify each file into a work type using the Work Type Detection Patterns in the Quality Gate Protocol below.

### Step 2: Determine Profile
- If all files map to a single work type, use that profile directly
- If files span multiple work types, compute the union profile (see Union Semantics)
- If no pattern matches, default to `application_code`

### Step 3: Echo Selection
Before deploying gate agents, announce the selection and render an initial Gate Panel with all gates in `PENDING` status:
"Selected gate profile: [work_type]. Running [N] gate agents: [agent list]."
For union profiles: "Mixed changeset detected ([types]). Union profile: Gate 1 [agents], Gate 2 [agents]."

### Step 3.5: Materialize PLAN_CONTEXT

<!-- user-comms: say "the task requirements" not "PLAN_CONTEXT" -->
<!-- user-comms: say "retrieving task details" not "FETCH_ISSUE" -->
Before dispatching Gate 2 reviewers, resolve the plan context so reviewers assess against actual requirements — not self-inferred scope.

**Resolution order:**

1. **Plan file first**: Search `.claude/plans/` for a file whose filename contains the current TASK_ID, or whose contents reference the TASK_ID. If found, read its full contents as PLAN_CONTEXT.
2. **Fallback to FETCH_ISSUE**: If no plan file matches, use the loaded platform skill's FETCH_ISSUE operation to retrieve the issue body. Use that as PLAN_CONTEXT.
3. **Graceful degradation**: If neither source yields content, omit PLAN_CONTEXT from the reviewer's prompt and log a warning: "PLAN_CONTEXT not found — reviewer will assess without plan reference." This is not a gate failure.

When resolved, inject the content into the Gate 2 reviewer prompt as:
```
<plan_context>
[full plan content or issue body here]
</plan_context>
```

### Step 4: Deploy Gates
- Deploy Gate 1 agents (if any) -- these are blocking, must all pass before Gate 2
- Deploy Gate 2 agents in parallel -- all must pass
- For SME reviewer agents deployed via the code-review skill, construct the prompt using XML-wrapped fields to prevent field bleeding:
  ```
  <skill_content>
  [contents of skills/code-review/SKILL.md]
  </skill_content>

  <specialty_content>
  [contents of matching specialty file, if applicable; omit this entire block if no specialty file]
  </specialty_content>

  <plan_context>
  [materialized plan content]
  </plan_context>

  <scope>
  [glob patterns]
  </scope>

  TEST_RUNNER_RESULTS: [paste Gate 1 test-runner JSON output here; omit if Gate 1 was not run for this work type]
  ```
  Note: For SME reviewers (via code-review skill), `all_checks_passed` is computed by takeoff from `blocking_issues.length === 0 && scope_violations.length === 0`. The reviewer does not emit this field.
- For work types with no Gate 1, proceed directly to Gate 2

### Step 5: Conservative Dirty-Bit Caching
If a gate iteration requires the coding agent to make changes, re-run ONLY gates whose scope was affected:
- Skip re-running a gate only if ZERO files in that gate's scope changed since its last pass
- When in doubt, re-run the gate (conservative approach)

<%- include('partials/agent-deployment-template') %>

<%- include('partials/quality-gate-protocol', { role: 'orchestrator' }) %>

### LOOP CHECKPOINT: Return to Per-Unit Cycle

After the gates pass for the current work unit, check TodoWrite for remaining units:
- **Pending units remain** --> return to Per-Unit Cycle step 1 for the next unit
- **All units completed** --> proceed to Learning Extraction below

Do not fall through to Completion while TodoWrite has pending work units.

## Learning Extraction

After all quality gates pass but before presenting to the user, check whether any gate required 2 or more iterations. If so:

1. Review the `blocking_issues` from each failed attempt
2. Identify recurring categories (same class of issue across iterations)
3. For each recurring category, draft a one-line CLAUDE.md entry that would prevent recurrence

Apply a two-question filter: (a) Would Claude make this mistake again without the entry? (b) Is the lesson non-obvious from existing files?

Maximum 3 suggestions per session. Never auto-apply these entries -- always direct the user to `/reaper:claude-sync` for review. If no patterns recurred, omit this section from the output.

---

### STOP -- Verify Before Completion

Do not read past this point without performing the verification steps below. This is a mandatory checkpoint.

1. **Re-read**: Use **TaskList** to read all TodoWrite entries right now
2. **Count**: Count entries with status "pending" or "in_progress", excluding "User review", "Merge", "Close", and "Clean up" entries
3. **Decide**:
   - If count > 0: State "N work units remain -- returning to Per-Unit Cycle" and go back to Strategy Execution
   - If count === 0: Proceed to Completion below

---

## Completion and User Feedback

**Trigger condition (verified by the STOP checkpoint above):** The TaskList re-read confirmed zero pending or in_progress work unit entries. All quality gates for the final unit have passed.

If you did not perform the STOP checkpoint above, go back and do it now.

When these conditions are met, present a **Touchdown Card** followed by a work summary. Use the gauge vocabulary from the Visual Vocabulary section.

```
  TOUCHDOWN
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Task:       [TASK-ID]
  Branch:     [branch-name]
  Units:      [N of N completed]
  ██████████  LANDED
```

Then render a final **Gate Panel** showing the cumulative result of all gates across all work units. Each gate row should show `PASS` with its aggregate metrics (total tests passed, overall coverage, total issues found).

After the cards, present the work summary in this format:

```markdown
### What Was Built
[Brief description of implemented functionality]

### Files Changed
[List of modified files with brief descriptions]

### How to Test
[Instructions for the user to verify the work]

### Suggested CLAUDE.md Updates
[Only if learning extraction produced suggestions]
These patterns caused multiple iteration cycles:
- `[entry]`
Run `/reaper:claude-sync` to review and apply.

---
**Control tower, how do we look?** I can adjust the approach, run additional checks,
or address any concerns before final landing.

When you're satisfied, I'll bring her in for landing on develop.
```

### Response Handling

| User Response | Action |
|---------------|--------|
| Feedback or questions | Address concerns, re-run quality gates if changes were made |
| "looks good" / "nice work" | Ask: "Shall I merge to develop?" |
| "merge" / "ship it" / "approved" | Deploy reaper:branch-manager to merge |
| Silence or unclear | Ask: "Any feedback, or ready to merge?" |

## Worktree Cleanup

After a successful merge, invoke the `worktree-manager` skill to safely remove the session worktree.

For **medium_single_branch** and **very_small_direct** strategies: invoke the worktree-manager skill to remove the shared worktree after all units complete and gates pass (at Completion, not per-unit). Always go through the worktree-manager skill -- never run `git worktree remove` directly.

## Quick Reference

1. Parse inputs and query task system
2. Discover plan file and extract context
3. Detect pre-planned structure or deploy reaper:workflow-planner
4. Validate work package sizes
5. Write plan to TodoWrite

**Per-unit loop (repeat for EACH work unit):**

>  **6. Render TAKING OFF announcement** for the current work unit
>  **7. Deploy coding agent** for the current work unit
>  **8. Classify files and select gate profile** (Dynamic Gate Selection)
>  **9. Run quality gates** through the profile sequence
>  **10. Auto-iterate** on gate failures (differential retry limits)
>  **--> Check TodoWrite: pending units remain? Loop to step 6**

11. Extract learning patterns from multi-iteration gates
12. Present completed work to user
13. Merge on explicit user approval
14. Clean up worktrees
