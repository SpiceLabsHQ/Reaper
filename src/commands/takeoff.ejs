---
description: Dispatch agents through quality gates until work lands on your desk.
---

# Work Supervisor Mode with Iterative Quality Loops

**Task**: [ARGUMENTS]

<%- include('partials/orchestrator-role-boundary') %>

<%- include('partials/task-system-operations') %>

## Input Processing

### Parse User Input

Extract from [ARGUMENTS] using natural language understanding:

1. **Task identifier** -- look for task-like patterns (PROJ-123, repo-a3f, #456, sprint-5-auth). May be absent.
2. **Worktree path** -- look for an explicit `./trees/...` path. May be absent.
3. **Description** -- all remaining text after extracting the above.

### Validation Rules

The orchestrator can start with just a task ID (unlike coding agents) because it can query the task system.

- **Task ID provided**: Use FETCH_ISSUE to retrieve details. If the query fails and no description was provided, reject the input.
- **No task ID**: Require a detailed description (more than 10 characters). Generate a slug-based task ID from the description.
- **Both provided**: Combine fetched details with the user-provided description for richer context.

**Valid inputs:**
- "PROJ-123" (fetches details from Jira)
- "repo-a3f" (fetches details from Beads)
- "PROJ-123: Fix login bug where email validation fails for plus signs" (enriched)
- "Fix the payment timeout issue - transactions over 30s fail, need retry logic" (description-only)

**Invalid inputs (reject):**
- "fix bug" (too vague, no task ID)
- "" (empty)

### Build Context

After parsing, assemble the implementation context:
- If FETCH_ISSUE succeeded, use the fetched details (and append any user-provided description)
- If no task system query was possible, use the user description as the full context
- Set WORKTREE_PATH to the user-specified path, or generate one as `./trees/[TASK_ID]-work`

## Plan File Discovery

Search `.claude/plans/` for a matching plan file from a prior `/reaper:flight-plan` session. Match by task ID in filename first, then by task ID in file contents. When a match is found, read the file and extract sections according to the priority below.

<%- include('partials/plan-file-schema', { mode: 'reader' }) %>

Append any extracted Research and Strategy sections to the implementation context so downstream agents receive codebase insights gathered during planning.

## Pre-Planned Detection

Check whether the task already has child issues with acceptance criteria (indicating it was decomposed during flight-plan):

1. Use LIST_CHILDREN to get direct children of the task
2. If children exist and have acceptance criteria, mark the task as **pre-planned**
3. Use QUERY_DEPENDENCY_TREE to understand execution ordering among children

**If pre-planned**: Extract work units from child issues using the full scope rule:
- **Closed** children: skip (already completed)
- **Open, unblocked** children: execute immediately
- **Open, blocked** children: execute after their blockers complete

Dependencies determine execution ORDER, not whether a task is included. Every non-closed child must appear in the plan.

Select strategy based on non-closed child count: 1 child uses very_small_direct, 2-4 uses medium_single_branch, 5+ uses large_multi_worktree.

**If not pre-planned**: Proceed to the Planning section below.

## Worktree Management

Use the `worktree-manager` skill for all worktree operations (creation, status checks, cleanup). Never run `git worktree remove` or `rm -rf` on worktree paths directly -- these can break the Bash tool's working directory for the rest of the session.

## Planning

When the plan file already contains Work Units and Strategy, skip the planner and use those directly.

Otherwise, deploy reaper:workflow-planner to analyze the task and produce a strategy selection with work units. Pass the full implementation context (including any plan file research) as input.

If the plan file has Research but no Work Units, deploy the planner with the research as additional context so it does not repeat codebase investigation.

## Work Package Validation

After obtaining work units (from pre-planned extraction, plan file, or workflow-planner), validate each package:

- Maximum 5 files per work unit
- Maximum 500 lines of code per work unit
- Maximum 2 hours estimated per work unit

If any package exceeds these limits, redeploy reaper:workflow-planner with instructions to split the oversized packages into smaller, context-safe units.

<%- include('partials/todowrite-plan-protocol') %>

## Strategy Execution

Follow the planner's `agent_deployment_sequence` to execute work units in order. For each work unit:

1. Update TodoWrite to mark the unit as in_progress
2. Deploy the specified coding agent using the deployment template below
3. Run quality gates on the completed work
4. Update TodoWrite to mark the unit as completed

When multiple work units share a group number and have no mutual dependencies, deploy their agents in parallel (multiple Task calls in a single message).

**Update TodoWrite immediately after each state change** -- never batch updates. If the session disconnects, the TodoWrite plan is the recovery mechanism.

### Strategy Notes

- **very_small_direct**: Deploy a single coding agent. No worktree isolation needed. Quality gates still apply.
- **medium_single_branch**: Multiple agents work sequentially or in parallel on the same branch. Ensure file assignments do not overlap for parallel work.
- **large_multi_worktree**: Each agent gets its own worktree. Use the worktree-manager skill to create isolated worktrees. Deploy reaper:branch-manager to merge completed worktrees.

## Dynamic Gate Selection

After a coding agent completes work, determine the appropriate quality gates:

### Step 1: Classify Files
From the coding agent's `files_modified` list, classify each file into a work type using the Work Type Detection Patterns in the Quality Gate Protocol below.

### Step 2: Determine Profile
- If all files map to a single work type, use that profile directly
- If files span multiple work types, compute the union profile (see Union Semantics)
- If no pattern matches, default to `application_code`

### Step 3: Echo Selection
Before deploying gate agents, announce the selection:
"Selected gate profile: [work_type]. Running [N] gate agents: [agent list]."
For union profiles: "Mixed changeset detected ([types]). Union profile: Gate 1 [agents], Gate 2 [agents]."

### Step 4: Deploy Gates
- Deploy Gate 1 agents (if any) -- these are blocking, must all pass before Gate 2
- Deploy Gate 2 agents in parallel -- all must pass
- For dual-role agents (e.g., code-reviewer in GATE_MODE), pass: GATE_MODE: true, CRITERIA_PROFILE: [work_type]
- For work types with no Gate 1, proceed directly to Gate 2

### Step 5: Conservative Dirty-Bit Caching
If a gate iteration requires the coding agent to make changes, re-run ONLY gates whose scope was affected:
- Skip re-running a gate only if ZERO files in that gate's scope changed since its last pass
- When in doubt, re-run the gate (conservative approach)

<%- include('partials/agent-deployment-template') %>

<%- include('partials/quality-gate-protocol', { role: 'orchestrator' }) %>

## Learning Extraction

After all quality gates pass but before presenting to the user, check whether any gate required 2 or more iterations. If so:

1. Review the `blocking_issues` from each failed attempt
2. Identify recurring categories (same class of issue across iterations)
3. For each recurring category, draft a one-line CLAUDE.md entry that would prevent recurrence

Apply a two-question filter: (a) Would Claude make this mistake again without the entry? (b) Is the lesson non-obvious from existing files?

Maximum 3 suggestions per session. Never auto-apply these entries -- always direct the user to `/reaper:claude-sync` for review. If no patterns recurred, omit this section from the output.

## Completion and User Feedback

When all quality gates pass, present completed work:

```markdown
## Touchdown! Ready for Inspection

### What Was Built
[Brief description of implemented functionality]

### Quality Validation
[List each gate that ran with its result summary]

### Files Changed
[List of modified files with brief descriptions]

### How to Test
[Instructions for the user to verify the work]

### Suggested CLAUDE.md Updates
[Only if learning extraction produced suggestions]
These patterns caused multiple iteration cycles:
- `[entry]`
Run `/reaper:claude-sync` to review and apply.

---
**Control tower, how do we look?** I can adjust the approach, run additional checks,
or address any concerns before final landing.

When you're satisfied, I'll bring her in for landing on develop.
```

### Response Handling

| User Response | Action |
|---------------|--------|
| Feedback or questions | Address concerns, re-run quality gates if changes were made |
| "looks good" / "nice work" | Ask: "Shall I merge to develop?" |
| "merge" / "ship it" / "approved" | Deploy reaper:branch-manager to merge |
| Silence or unclear | Ask: "Any feedback, or ready to merge?" |

## Worktree Cleanup

After a successful merge, invoke the `worktree-manager` skill to safely remove the session worktree.

## Quick Reference

1. Parse inputs and query task system
2. Discover plan file and extract context
3. Detect pre-planned structure or deploy reaper:workflow-planner
4. Validate work package sizes
5. Write plan to TodoWrite
6. Execute work units with coding agents
7. Classify files and select gate profile (see Dynamic Gate Selection)
8. Run selected quality gates through the profile sequence
9. Auto-iterate on failures (differential retry limits per agent)
10. Extract learning patterns from multi-iteration gates
11. Present completed work to user
12. Merge on explicit user approval
13. Clean up worktrees
