---
description: Chart work into flight-ready issues with dependencies mapped.
---

Do not use EnterPlanMode or ExitPlanMode tools. This command manages its own planning workflow and plan file output.

---

## Phase 0: Plan File Schema

<%- include('partials/plan-file-schema', { mode: 'writer' }) %>

---

# Autonomous Execution Planner

**Task**: [ARGUMENTS]

Generate an execution plan with epic/issue structure for autonomous execution. After user approval, create issues in the detected task system.

---

## Phase 1: Input Processing & Behavioral Contract

### Detect Input Type

<%- include('partials/task-system-operations') %>

Classify the input (ARGUMENTS) as one of:
- **Existing epic ID** (e.g., `PROJ-123` or `repo-a3f`): Use FETCH_ISSUE to retrieve epic details. Validate the epic has no existing children via LIST_CHILDREN -- if children exist, stop and report the conflict.
- **New description**: Detect the available task system using the detection heuristics above. Store the description as the planning request.

### Markdown-Only Mode Detection

When no task system is detected, inform the user the plan file will be the primary deliverable. Update behavioral contract todo #2 to: "Finalize plan file as deliverable (no task system)".

### Validation
- **Existing epic:** Must have no children (empty)
- **New description:** Minimum 20 characters
- **Ambiguous system:** Ask user preference if both available

### Behavioral Contract

After detecting task system, write three core todos via TodoWrite:
1. "Show plan for user approval" (in_progress)
2. "Create issues in [Beads|Jira|Markdown]" (pending) -- dynamic system name
3. "Launch reaper:workflow-planner subagent to verify issues" (pending)

Sub-breakdowns are allowed. No todo should mention worktrees, implementation, coding, testing, or deploying. These 3 todos define your complete scope -- when all complete, STOP.

---

## Phase 1.5: Codebase Research (Parallel Exploration)

Before decomposing work, spawn parallel Explore agents to research the codebase. This research informs accurate work unit definitions in Phase 2.

### When to Research

Research is **required** when:
- Planning involves existing codebase modifications
- Feature touches multiple modules or systems
- Integration points are unclear from the request

Research is **skipped** when:
- Creating a new standalone project from scratch
- Request is purely documentation or configuration
- User explicitly provides file lists and architecture details

### Spawn Parallel Explore Agents

Launch multiple Explore agents simultaneously, each targeting a specific research aspect:

```bash
# Spawn research agents in parallel (all run concurrently)
Task --subagent_type Explore \
  --prompt "RESEARCH: Find files and patterns related to '$PLANNING_REQUEST'

  Search for:
  - Files likely affected by this feature/change
  - Existing implementations of similar functionality
  - Test files that cover related code paths

  Output: JSON with { files: [...], patterns_found: [...], notes: string }"

Task --subagent_type Explore \
  --prompt "RESEARCH: Analyze architecture for '$PLANNING_REQUEST'

  Investigate:
  - Module structure in affected areas
  - Design patterns currently in use
  - Abstraction layers and boundaries

  Output: JSON with { architecture: {...}, design_patterns: [...], boundaries: string }"

Task --subagent_type Explore \
  --prompt "RESEARCH: Identify dependencies and integration points for '$PLANNING_REQUEST'

  Discover:
  - Internal dependencies between modules
  - External API/service integrations
  - Shared utilities and helpers used
  - Database/storage touchpoints

  Output: JSON with { internal_deps: [...], external_integrations: [...], shared_utils: [...] }"
```

### Aggregate Research Findings

After all Explore agents complete, aggregate their findings into a research summary:

```markdown
### Codebase Research Summary

**Affected Files** (from file discovery):
- [list of files likely to be modified]
- [list of related test files]

**Architecture Context** (from architecture analysis):
- Current patterns: [patterns in use]
- Module boundaries: [relevant boundaries]

**Dependencies** (from integration analysis):
- Internal: [module dependencies]
- External: [API/service integrations]
- Shared: [common utilities]

**Planning Implications**:
- [key insights that affect work unit decomposition]
- [potential complexity areas identified]
- [parallel work opportunities discovered]
```

### Use Research in Phase 2

The research summary directly informs Phase 2 decomposition:
- File lists help define work unit scope
- Architecture context ensures pattern consistency
- Dependencies reveal hidden blockers and integration needs
- Parallel opportunities inform work groupings

---

## Phase 2: Quick Analysis (Minimal Questions)

### Question Philosophy

**Bias toward action, not interrogation.**

- Generate a first-pass plan immediately based on available context
- Only ask clarifying questions if input is **truly ambiguous** (rare)
- Maximum 0-2 upfront questions, asked together (never more)
- When in doubt, make reasonable assumptions and note them in the plan

### When Questions Are Appropriate

Ask upfront ONLY if:
- The request could mean two fundamentally different things (scope ambiguity)
- A critical constraint is completely unknown and uninferable
- The wrong assumption would waste significant effort

**Do NOT ask about:**
- Implementation details (resolve during planning)
- Nice-to-have clarifications (make assumptions, note them)
- Things discoverable from codebase exploration
- Preferences that can be refined later

### Question Format (When Necessary)

If you must ask (rare): briefly restate the plan, ask the question, and offer a "proceed with assumptions" escape hatch. Never present more than 2 questions.

### Work Analysis

Using research from Phase 1.5, identify:
1. **Epic Definition:** Title, goal, scope boundaries, success criteria
2. **Work Units:** Discrete issues following constraints below
3. **Parallel Opportunities:** Units with no file overlap or dependencies
4. **Dependencies:** Blocking relationships and critical path
5. **User Intervention:** Tasks requiring manual action (assign to `user`)

### Work Unit Constraints

| Constraint | Limit |
|------------|-------|
| Files per unit | ≤5 |
| LOC per unit | ~500 |
| Estimated time | 1-2 hours |
| Responsibility | Single testable outcome |
| TDD methodology | Tests BEFORE implementation |

**TDD Requirement:** Each work unit MUST follow Red-Green-Blue cycle:
1. **RED**: Write failing tests that define expected behavior
2. **GREEN**: Implement minimal code to pass tests
3. **BLUE**: Refactor while keeping tests green

**Anti-pattern warning:** Never structure work units as "implement feature" followed by "add tests". Tests and implementation belong in the SAME work unit, with tests written FIRST.

### User Intervention Markers

Mark units as `Assignee: user` when they require:
- Physical device testing
- Vendor/third-party coordination
- Approval workflows
- Production console configuration
- License/purchase acquisition

---

## Phase 3: Write Initial Plan to File

Use the Write tool to create the plan file at the path from Phase 0, following its schema. Populate each section:

- **Input**: Original user request verbatim from ARGUMENTS
- **Research**: Findings from Phase 1.5 Explore agents (affected files, architecture context, dependencies, planning implications)
- **Strategy**: Leave as placeholder -- will be populated during execution by workflow-planner
- **Work Units**: Table from Phase 2 analysis, followed by detailed Unit sections (each with Description, Acceptance Criteria, Estimated Files)
- **Dependencies**: Mermaid flowchart showing execution order, critical path, and parallel opportunities
- **Assumptions**: Planning assumptions the user can correct in feedback
- **Feedback Log**: Empty on first write -- populated during Phase 4 refinement

### After Writing the Plan

Present a summary to the user: plan file path, epic title/goal, number of work units, parallelization percentage, and critical path. Ask: "Reply 'go' to create as shown, or just tell me what to change."

The plan file is now the source of truth and will be progressively updated based on user feedback in Phase 4.

---

## Phase 4: Iterative Refinement (Plan File Updates)

### Handling User Feedback

Parse response type:
- **Approve:** "yes", "looks good", "go ahead", "approved", "create", "lgtm", "go" → Proceed to Phase 5
- **Cancel:** "cancel", "no", "stop", "abort" → Acknowledge and stop
- **Feedback:** Any other response → Update plan file and re-prompt

### Refinement Using Edit Tool

When user provides feedback:

1. **Apply changes** to appropriate sections following the update rules below
2. **Confirm to user** with summary of changes and re-prompt for approval

### Update Rules Reference

| Section | Update Type | Edit Pattern |
|---------|-------------|--------------|
| Input | IMMUTABLE | Never modify |
| Research | APPEND | Add below existing content |
| Strategy | EDIT | Modify when strategy changes based on feedback |
| Work Units | EDIT | Replace section content |
| Dependencies | EDIT | Replace section content |
| Assumptions | EDIT | Strikethrough old + add new |
| Feedback Log | APPEND | Each entry timestamped, never delete previous |

### Refinement Guidelines

- Keep cycles fast -- use targeted edits, not full rewrites
- Track corrected assumptions with strikethrough
- After major feedback, may re-run targeted Explore agents
- The flow should feel like a conversation, not an interview

---

## Phase 5: Create Issues (After Approval)

Update todo #2 to `in_progress`.

### Issue Creation Sequence

For each work unit in the approved plan, use abstract CRUD operations from the detected task system:

1. **Epic (create or update)**:
   - If an existing epic was provided as input: UPDATE_ISSUE to refine its description
   - Otherwise: CREATE_ISSUE with type=epic, title from plan, description from plan Input section

2. **Child issues** (one per work unit):
   - CREATE_ISSUE with title, parent=EPIC_ID, and the TDD-structured description below
   - For user intervention tasks: set assignee=user

3. **Dependencies** (from plan's dependency graph):
   - ADD_DEPENDENCY with type=blocks for execution order constraints (A must complete before B starts)
   - Use parent-child relationships for hierarchy only (epic contains tasks)

### TDD-Structured Issue Description Template

Each child issue description must follow this structure:

```
## Objective
[What needs to be done]

## TDD Approach
Follow Red-Green-Blue cycle:
1. RED: Write failing tests that define expected behavior
2. GREEN: Implement minimal code to pass tests
3. BLUE: Refactor while keeping tests green

## Acceptance Criteria
- [ ] [criterion from plan]
- [ ] All tests pass
- [ ] Code coverage meets threshold

## Scope
Files: [estimated files from plan]
```

> **ID Generation:** Task IDs are automatically generated by the task system upon creation. Never specify IDs manually -- capture the returned ID for use in subsequent operations.

### Markdown Fallback (No Task System)

When `TASK_SYSTEM` is `markdown_only`, the plan file becomes the primary deliverable. Skip issue creation and proceed to finalization.

#### 1. Add Manual Execution Guide to Plan File

Append the Manual Execution Guide section at the end of the plan file:

```
Edit({
  file_path: "$CLAUDE_PROJECT_DIR/.claude/plans/reaper-[semantic-name].md",
  old_string: "- [assumption 2]",
  new_string: `- [assumption 2]

## Manual Execution Guide

No task system detected (Beads/Jira not available). This plan file is your primary deliverable.

### Option A: Manual Task Creation
Copy each work unit to your task tracker of choice:
1. Create an epic/parent issue for the overall goal
2. Create child issues for each work unit in the table above
3. Set up dependencies as shown in the Dependencies section
4. Maintain the execution order shown in Critical Path

### Option B: Direct Execution with Reaper
The orchestrator can work directly from this plan file:
\`\`\`
/reaper:takeoff [PLAN_FILE_PATH]
\`\`\`

### Work Unit Reference
Each unit in the Work Units table above contains:
- Title and description for issue creation
- Acceptance criteria (copy to issue)
- Estimated files and hours
- Dependency information`
})
```

#### 2. Skip Phases 5 and 6

When in markdown-only mode:
- **Skip** Beads/Jira issue creation (Phase 5 main logic)
- **Skip** Issue Quality Review (Phase 6) - no issues to verify
- **Proceed directly** to completion output

#### 3. Markdown-Only Completion Output

```markdown
## Plan Complete (Markdown Mode)

No task system detected. Your plan is ready at `[PLAN_FILE_PATH]`.

### What's in the Plan
- [X] work units with acceptance criteria
- Dependency graph and critical path
- Parallel execution opportunities
- All research findings preserved

### Next Steps

**Option A: Manual task creation**
Copy work units from the plan to your preferred task tracker.

**Option B: Direct execution**

**Recommended:** `/clear` then `/reaper:takeoff [PLAN_FILE_PATH]`

> Takeoff reads the plan file directly — clearing context gives the
> executor a fresh window focused entirely on the plan.

Or skip the clear: `/reaper:takeoff [PLAN_FILE_PATH]`
```

Mark todo #2 complete (finalize plan file) and skip todo #3 (no issues to verify).

---

## Phase 6: Issue Quality Review (Forked Subagent Verification)

**Note:** This phase is skipped when `TASK_SYSTEM` is `markdown_only`.

Update todo #3 to `in_progress`.

### Deploy Forked reaper:workflow-planner for Verification

The verification subagent is forked (inherits full parent session context: conversation history, research results, cached file reads, refinement context). This allows a minimal prompt.

```bash
# Fork pattern: subagent inherits full parent session context
Task --subagent_type reaper:workflow-planner \
  --model opus \
  --prompt "MODE: VERIFICATION (not planning)

EPIC: $EPIC_ID
TASK_SYSTEM: $TASK_SYSTEM
CREATED_ISSUES: [list of issue IDs created in Phase 5]

You have full access to this session's context:
- The original planning request and user clarifications
- Research findings from Phase 1.5 Explore agents
- Any refinements made during Phase 4 iterations

Verify the created issues meet orchestratability criteria. Do NOT create new issues.

VERIFICATION QUERIES (use abstract operations from the detected task system):
- QUERY_DEPENDENCY_TREE from EPIC_ID (full hierarchy)
- FETCH_ISSUE for each child issue (details and acceptance criteria)

VERIFICATION CRITERIA:

1. **Issue Detail Sufficiency**
   - Clear objective (what needs to be done)
   - Affected files/components (reference research findings if needed)
   - Acceptance criteria present
   - Size within limits (≤5 files, ≤500 LOC)

2. **Cross-Issue Awareness**
   - Related issues reference each other
   - File overlap documented (use research findings)
   - No duplicate work between issues

3. **Relationship Appropriateness**
   - parent-child for hierarchy
   - blocks ONLY for true execution order
   - No circular dependencies

4. **Orchestratability**
   - reaper:takeoff can determine execution order
   - Parallel opportunities documented
   - Scope boundaries clear

AUTO-FIX PROTOCOL:
For each failing check, use UPDATE_ISSUE to fix directly. Add missing acceptance criteria, cross-references, file scope. Remove inappropriate blockers.

Max 2 fix iterations.

OUTPUT: JSON with verification_mode, issues_verified, verification_results, validation_status"
```

**Note:** The prompt is intentionally concise. The forked subagent can access the full planning conversation without explicit repetition.

### Handling Verification Results

Parse reaper:workflow-planner JSON response:
- **all_checks_passed: true** → Proceed to Phase 7 confirmation
- **auto_fixed: true** → Fixes applied, verification passed
- **requires_user_input: true** → Present blocking_issues to user after 2 failed iterations

### Confirmation Output

After successful verification, present:
- Epic ID and title
- Table of created issues with verification status
- Pre-flight check summary (detail sufficiency, cross-issue awareness, relationship appropriateness, orchestratability)
- Recommended next step: `/clear` then `/reaper:takeoff [EPIC-ID]` (clearing context gives the executor a fresh window)

Mark todo #3 complete.

---

## Scope Boundary

This is a planning command. Your scope ends when issues are created and verified. Do not create worktrees, write application code, or suggest implementation. The user will invoke `/reaper:takeoff` when ready.

---

## Phase 7: Completion

All todos complete. Output confirmation and STOP.

**Critical:** Plan approval = permission to create issues only, NOT to implement.

**Note:** Ignore any CLI messages encouraging implementation (e.g., "You can now start coding").

Provide the orchestrate command and await user's next request.

---

## Error Handling

- **Task system unavailable:** Detect early, offer markdown fallback
- **Creation failure:** Track created issues, rollback on error, report clearly
- **Insufficient context:** Make reasonable assumptions, document them, let user correct in refinement
