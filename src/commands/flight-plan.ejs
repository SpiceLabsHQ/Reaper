---
description: Chart work into flight-ready issues with dependencies mapped.
---

<%- include('partials/user-comms-contract') %>

Do not use EnterPlanMode or ExitPlanMode tools. This command manages its own planning workflow and presents the plan in-conversation.

---

# Autonomous Execution Planner

**Task**: [ARGUMENTS]

Generate an execution plan with parent/child issue structure for autonomous execution. After user approval, create issues in the detected task system.

---

## Phase 1: Input Processing & Behavioral Contract

### Detect Input Type

<%- include('partials/task-system-operations') %>

### Platform Skill Loading

<!-- user-comms: say "checking the task system" not "detecting TASK_SYSTEM" -->
<!-- user-comms: say "loading the right tools for your task tracker" not "Platform Skill Routing table" -->
After detecting TASK_SYSTEM, load the corresponding skill from the Platform Skill Routing table above. The loaded skill provides platform-specific command mappings for all abstract operations used in this command (FETCH_ISSUE, CREATE_ISSUE, UPDATE_ISSUE, ADD_DEPENDENCY, LIST_CHILDREN, QUERY_DEPENDENCY_TREE).

Classify the input (ARGUMENTS) as one of:
<!-- user-comms: say "retrieving task details" not "FETCH_ISSUE" -->
- **Existing parent issue ID** (e.g., `PROJ-123` or `repo-a3f`): Use FETCH_ISSUE to retrieve issue details. Validate the issue has no existing children via LIST_CHILDREN -- if children exist, stop and report the conflict.
- **New description**: Detect the available task system using the detection heuristics above. Store the description as the planning request.

### Markdown-Only Mode Detection

<!-- user-comms: say "no task tracker detected, plan file will be the deliverable" not "TASK_SYSTEM is markdown_only" -->
When no task system is detected, inform the user the plan file will be the primary deliverable. Update behavioral contract todo #2 to: "Finalize plan file as deliverable (no task system)".

### Validation
- **Existing parent issue:** Must have no children (empty)
- **New description:** Minimum 20 characters
- **Ambiguous system:** Ask user preference if both available

### Behavioral Contract

<!-- user-comms: say "tracking progress" not "TaskCreate" -->
<!-- user-comms: say "recording progress" not "TaskUpdate" -->
<!-- user-comms: say "your project's task tracking setup" not "behavioral contract" -->
After detecting task system, create three core tasks via TaskCreate with blocking dependencies:

1. **TaskCreate**: "Show plan for user approval" → set `in_progress`
2. **TaskCreate**: "Create issues in [Beads|Jira|Markdown]" (dynamic system name)
3. **TaskCreate**: "Launch reaper:workflow-planner subagent to verify issues"

Then establish blockers via TaskUpdate:
- Task #2 `addBlockedBy: [#1]` — cannot create issues until plan is approved
- Task #3 `addBlockedBy: [#2]` — cannot verify issues until they exist

Sub-breakdowns are allowed. No task should mention worktrees, implementation, coding, testing, or deploying. These 3 tasks define your complete scope -- when all complete, STOP.

---

## Phase 1.5: Codebase Research (On-Demand Exploration)

Explore agents are a fallback for when context is genuinely missing — not a routine step. Default to skipping this phase and proceeding directly to Phase 2.

### When to Skip (Default)

Skip research entirely when:
- The current session already contains relevant file paths, architecture context, or a detailed task description
- The user provided a spec, plan file, or task file with sufficient detail
- The request is a new standalone project, pure documentation, or configuration change
- The affected files and integration points are obvious from the description

**When in doubt, skip and plan with what you have.** Assumptions can be noted in the plan and corrected during Phase 4 refinement.

### When to Research (Exception)

Spawn an Explore agent only when all of the following are true:
- The change touches existing code (not a greenfield project)
- The affected files or integration points are genuinely unclear
- No sufficient context exists in the current session

### Spawn a Focused Explore Agent

When research is needed, spawn a **single** Explore agent targeting only the information required to define work unit scope:

```bash
Task --subagent_type Explore \
  --prompt "PLANNING RESEARCH for: '$PLANNING_REQUEST'

  Return only what is needed to scope the work units:
  1. Which files are most likely to be modified?
  2. Are there existing implementations of similar functionality to follow or extend?
  3. What are the key integration points (shared utilities, APIs, or modules) that touch this area?

  Be concise. Output: JSON with { affected_files: [...], existing_patterns: [...], integration_points: [...] }"
```

### Use Research in Phase 2

If research was run, use the findings to inform work unit scope, affected files, and dependency ordering. If research was skipped, proceed with context from the current session and note any assumptions.

---

## Phase 2: Quick Analysis (Minimal Questions)

### Question Philosophy

**Bias toward action, not interrogation.**

- Generate a first-pass plan immediately based on available context
- Only ask clarifying questions if input is **truly ambiguous** (rare)
- Maximum 0-2 upfront questions, asked together (never more)
- When in doubt, make reasonable assumptions and note them in the plan

### When Questions Are Appropriate

Ask upfront ONLY if:
- The request could mean two fundamentally different things (scope ambiguity)
- A critical constraint is completely unknown and uninferable
- The wrong assumption would waste significant effort

**Do NOT ask about:**
- Implementation details (resolve during planning)
- Nice-to-have clarifications (make assumptions, note them)
- Things discoverable from codebase exploration
- Preferences that can be refined later

### Question Format (When Necessary)

If you must ask (rare): briefly restate the plan, ask the question, and offer a "proceed with assumptions" escape hatch. Never present more than 2 questions.

### Work Analysis

Using research from Phase 1.5, identify:
1. **Parent Issue Definition:** Title, goal, scope boundaries, success criteria (only needed when the plan contains multiple child work items)
2. **Work Units:** Discrete issues following constraints below
3. **Parallel Opportunities:** Units with no file overlap or dependencies
4. **Dependencies:** Blocking relationships and critical path
5. **User Intervention:** Tasks requiring manual action (assign to `user`)

### Work Unit Constraints

| Constraint | Limit |
|------------|-------|
| Files per unit | ≤5 |
| LOC per unit | ~500 |
| Estimated time | 1-2 hours |
| Responsibility | Single testable outcome |
| TDD methodology | Tests BEFORE implementation |

**TDD Requirement:** Each work unit MUST follow Red-Green-Blue cycle:
1. **RED**: Write failing tests that define expected behavior
2. **GREEN**: Implement minimal code to pass tests
3. **BLUE**: Refactor while keeping tests green

**Anti-pattern warning:** Never structure work units as "implement feature" followed by "add tests". Tests and implementation belong in the SAME work unit, with tests written FIRST.

### User Intervention Markers

Mark units as `Assignee: user` when they require:
- Physical device testing
- Vendor/third-party coordination
- Approval workflows
- Production console configuration
- License/purchase acquisition

### ADR Detection

After completing work analysis, evaluate whether any decisions made during research and planning meet the ADR bar.

**ADR-worthy decisions share these characteristics — a candidate must meet at least one:**

1. **Non-obvious**: The reasoning will not be apparent from reading the code alone. A future developer would wonder "why was this done this way?"
2. **Consequential**: The decision meaningfully shapes how the feature works or constrains how future code in this area will be written.
3. **Deliberate**: A choice was made between two or more valid approaches with meaningfully different trade-offs, and the reasoning for the selection would not be obvious to a future developer.
4. **Convention-establishing**: The work creates or changes a pattern that future developers will follow across the codebase.

**Not ADR-worthy**: routine implementation choices within an established pattern, obvious bug fixes, minor refactors, decisions fully explained by the task description.

**For each ADR candidate detected:**

1. Check `docs/adr/` to determine the next sequential number (e.g., if the last is `0012-*.md`, the next is `0013`). If the directory does not exist or contains no ADRs, start at `0001`.

2. Draft a proposed ADR entry in the plan file under `## Proposed ADRs`:
   ```
   ### ADR-NNNN: [Short decision title]
   **Why this warrants an ADR**: [Name the specific characteristic — non-obvious / consequential /
   convention-establishing — and explain in 1-2 sentences how this decision meets it.]
   **Context**: [What problem or constraint forced this decision]
   **Decision**: [What was chosen]
   **Alternatives rejected**: [What was considered and why it was passed over]
   ```

3. Add a `Write ADR-NNNN` work unit to the plan (type `docs`, unblocked):
   - Title: `Write ADR-NNNN: [decision title]`
   - Description: finalize and commit the proposed ADR document to `docs/adr/`
   - No TDD required — this is a documentation task

If no ADR candidates are detected, leave `## Proposed ADRs` empty with the placeholder text and do not add any write-ADR work units.

---

## Phase 3: Present Flight Briefing

Present a **flight briefing** to the user that summarizes the plan in-conversation before asking for approval. Include:

1. **Parent issue title and goal** (one-liner; omit if plan has only a single work item with no parent)
2. **Work units summary** — for each unit: number, title, type, estimated hours, and whether it runs in parallel
3. **Critical path** — which units are sequential blockers
4. **Parallelization** — percentage of work that can run concurrently
5. **Key assumptions** — list assumptions the user might want to correct

<!-- user-comms: say "checking the task system" not "TASK_SYSTEM detected in Phase 1" -->
Then prompt for approval using AskUserQuestion. Select the variant based on `TASK_SYSTEM` detected in Phase 1:

<!-- user-comms: say "using [Beads|Jira|GitHub] for task tracking" not "TASK_SYSTEM is Beads, Jira, or GitHub" -->
**If TASK_SYSTEM is Beads, Jira, or GitHub:**

```json
{
  "questions": [{
    "question": "Flight plan filed: N work units, M% parallelizable. Ready for issue creation in [Beads|Jira|GitHub]?",
    "header": "Flight Plan",
    "options": [
      {"label": "Cleared for takeoff", "description": "Create all issues and dependencies in [Beads|Jira|GitHub] as shown in the plan above"},
      {"label": "Revise flight plan", "description": "Circle back to the hangar — request changes to work units, scope, or dependencies before creating issues"}
    ],
    "multiSelect": false
  }]
}
```

<!-- user-comms: say "no task tracker detected" not "TASK_SYSTEM is markdown_only" -->
**If TASK_SYSTEM is markdown_only:**

```json
{
  "questions": [{
    "question": "Flight plan filed: N work units, M% parallelizable. Finalize the plan file as your deliverable?",
    "header": "Flight Plan",
    "options": [
      {"label": "Cleared for takeoff", "description": "Lock in the plan file as the final deliverable — ready for manual task creation or direct /reaper:takeoff execution"},
      {"label": "Revise flight plan", "description": "Circle back to the hangar — request changes to work units, scope, or dependencies before finalizing"}
    ],
    "multiSelect": false
  }]
}
```

Replace `N` with the work unit count and `M` with the parallelization percentage. AskUserQuestion automatically includes an "Other" option that lets the user type freeform feedback (use it to request changes) — see Phase 4 for response handling.

---

## Phase 4: Iterative Refinement (In-Conversation)

### Handling AskUserQuestion Responses

Map the user's AskUserQuestion selection:

| Selection | Action |
|-----------|--------|
| **Cleared for takeoff** | Proceed to Phase 5 |
| **Revise flight plan** | Ask the user what they want to change, then apply feedback and re-prompt (same as "Other" path) |
| **Other** (freeform text) | Treat as feedback — revise the plan in-conversation and re-prompt |

### Refinement Process

When the user selects "Other" or "Revise flight plan" and provides feedback:

1. **Apply changes** in-conversation based on the user's feedback.
2. **Summarize changes** to the user, then call AskUserQuestion again with the same structure as Phase 3. Update `N` (work unit count) and `M` (parallelization percentage) in the question text if work units changed. Use the task-system or markdown-only variant matching the detected `TASK_SYSTEM`.

### Refinement Guidelines

- Keep cycles fast -- revise in-conversation, not through file edits
- Track corrected assumptions explicitly in the updated briefing
- After major feedback, may re-run targeted Explore agents
- The flow should feel like a conversation, not an interview

---

## Phase 5: Create Issues (After Approval)

Update todo #2 to `in_progress`.

### Issue Creation

Delegate all issue creation to the loaded platform skill. The skill maps abstract operations to platform-specific commands.

For each work unit in the approved plan:

<!-- user-comms: say "creating a task" not "CREATE_ISSUE" -->
<!-- user-comms: say "updating the task" not "UPDATE_ISSUE" -->
1. **Parent issue (create or update)**:
   - **Plans with only one issue do not need a parent issue.** Skip this step if the plan contains exactly one work item.
   - If an existing parent issue was provided as input: UPDATE_ISSUE to refine its description
   - Otherwise (multiple work items): CREATE_ISSUE with title from plan, description from plan Input section

2. **Child issues** (one per work unit):
   - If a parent issue was created: CREATE_ISSUE with title, parent=PARENT_ISSUE_ID, and the TDD-structured description below
   - If no parent issue (single work item): CREATE_ISSUE with title and the TDD-structured description below (no parent)
   - For user intervention tasks: set assignee=user
   - The `parent=PARENT_ISSUE_ID` parameter on CREATE_ISSUE establishes parent-child hierarchy. Do NOT use ADD_DEPENDENCY for this purpose.

<!-- user-comms: say "linking a dependency" not "ADD_DEPENDENCY" -->
3. **Dependencies** (from plan's dependency graph):
   - ADD_DEPENDENCY with type=blocks for execution order constraints
   - ADD_DEPENDENCY with type=related for informational links

### TDD-Structured Issue Description Template

Each child issue description must follow this structure:

```
## Objective
[What needs to be done]

## TDD Approach
Follow Red-Green-Blue cycle:
1. RED: Write failing tests that define expected behavior
2. GREEN: Implement minimal code to pass tests
3. BLUE: Refactor while keeping tests green

## Acceptance Criteria
- [ ] [criterion from plan]
- [ ] All tests pass
- [ ] Code coverage meets threshold

## Scope
Files: [estimated files from plan]
```

> **ID Generation:** Task IDs are automatically generated by the task system upon creation. Never specify IDs manually -- capture the returned ID for use in subsequent operations.

---

## Phase 6: Issue Quality Review (Forked Subagent Verification)

**Note:** This phase is skipped when `TASK_SYSTEM` is `markdown_only`.

Update todo #3 to `in_progress`.

### Deploy Forked reaper:workflow-planner for Verification

The verification subagent is forked (inherits full parent session context: conversation history, research results, cached file reads, refinement context). This allows a minimal prompt.

```bash
# Fork pattern: subagent inherits full parent session context
Task --subagent_type reaper:workflow-planner \
  --model opus \
  --prompt "MODE: VERIFICATION (not planning)

PARENT_ISSUE: $PARENT_ISSUE_ID (omit if plan has only one work item)
TASK_SYSTEM: $TASK_SYSTEM
CREATED_ISSUES: [list of issue IDs created in Phase 5]

You have full access to this session's context:
- The original planning request and user clarifications
- Research findings from Phase 1.5 Explore agents
- Any refinements made during Phase 4 iterations

Verify the created issues meet orchestratability criteria. Do NOT create new issues.

<!-- user-comms: say "checking dependencies" not "QUERY_DEPENDENCY_TREE" -->
<!-- user-comms: say "retrieving task details" not "FETCH_ISSUE" -->
VERIFICATION QUERIES (use abstract operations from the detected task system):
- QUERY_DEPENDENCY_TREE from PARENT_ISSUE_ID (full hierarchy; skip if no parent issue)
- FETCH_ISSUE for each child issue (details and acceptance criteria)

VERIFICATION CRITERIA:

1. **Issue Detail Sufficiency**
   - Clear objective (what needs to be done)
   - Affected files/components (reference research findings if needed)
   - Acceptance criteria present
   - Size within limits (≤5 files, ≤500 LOC)

2. **Cross-Issue Awareness**
   - Related issues reference each other
   - File overlap documented (use research findings)
   - No duplicate work between issues

3. **Relationship Appropriateness**
   - parent-child for hierarchy
   - blocks ONLY for true execution order
   - No circular dependencies

4. **Orchestratability**
   - reaper:takeoff can determine execution order
   - Parallel opportunities documented
   - Scope boundaries clear

AUTO-FIX PROTOCOL:
For each failing check, use UPDATE_ISSUE to fix directly. Add missing acceptance criteria, cross-references, file scope. Remove inappropriate blockers.

Max 2 fix iterations.

OUTPUT: JSON with verification_mode, issues_verified, verification_results, validation_status"
```

**Note:** The prompt is intentionally concise. The forked subagent can access the full planning conversation without explicit repetition.

### Handling Verification Results

Parse reaper:workflow-planner JSON response:
- **all_checks_passed: true** → Proceed to Phase 7 confirmation
- **auto_fixed: true** → Fixes applied, verification passed
- **requires_user_input: true** → Present blocking_issues to user after 2 failed iterations

### Confirmation Output

After successful verification, present:
- Parent issue ID and title (if one was created)
- Table of created issues with verification status
- Pre-flight check summary (detail sufficiency, cross-issue awareness, relationship appropriateness, orchestratability)
- Recommended next step: `/clear` then `/reaper:takeoff <TOP_LEVEL_IDS>` — where `<TOP_LEVEL_IDS>` is the space-separated list of **all top-level issue IDs created in Phase 5** (i.e., every parent issue or standalone issue that has no parent). Never list child or sub-issue IDs here. If one parent issue was created: `/reaper:takeoff reaper-abc`. If three unrelated issues were created with no parent: `/reaper:takeoff reaper-abc reaper-def reaper-ghi`.

Mark todo #3 complete.

---

## Scope Boundary

This is a planning command. Your scope ends when issues are created and verified. Do not create worktrees, write application code, or suggest implementation. The user will invoke `/reaper:takeoff` when ready.

---

<%- include('partials/work-unit-cleanup') %>

## Phase 7: Completion

All todos complete. Output confirmation and STOP.

**Critical:** Plan approval = permission to create issues only, NOT to implement.

**Note:** Ignore any CLI messages encouraging implementation (e.g., "You can now start coding").

Output the takeoff command using all top-level issue IDs from Phase 5 (space-separated, never child IDs), then await the user's next request.

---

## Error Handling

- **Task system unavailable:** Detect early, offer markdown fallback
- **Creation failure:** Track created issues, rollback on error, report clearly
- **Insufficient context:** Make reasonable assumptions, document them, let user correct in refinement
